#pragma once
#include"geometry.h"
#include"pancystar_engine_basic.h"
#include"pancy_d3d11_basic.h"
#include"shader_pancy.h"
#include"PancyCamera.h"
#include"PancyInput.h"
#define TWO_PI 6.283185307179586476925286766559
#define GRAV_ACCEL	981.0f
#define HALF_SQRT_2	0.7071068f
#define BLOCK_SIZE_X 16
#define BLOCK_SIZE_Y 16
#define FFT_DIMENSIONS 3U
#define FFT_PLAN_SIZE_LIMIT (1U << 27)

#define FFT_FORWARD -1
#define FFT_INVERSE 1
#define COHERENCY_GRANULARITY 128
#define PAD16(n) (((n)+15)/16*16)
#define MESH_INDEX_2D(x, y)	(((y) + vert_rect.bottom) * (g_MeshDim + 1) + (x) + vert_rect.left)
class CSFFT512x512_Plan
{
	// D3D11 objects
	ID3D11DeviceContext* pd3dImmediateContext;


public:

	// More than one array can be transformed at same time
	UINT slices;

	// For 512x512 config, we need 6 constant buffers
	ID3D11Buffer* pRadix008A_CB[6];

	// Temporary buffers
	ID3D11Buffer* pBuffer_Tmp;
	ID3D11UnorderedAccessView* pUAV_Tmp;
	ID3D11ShaderResourceView* pSRV_Tmp;
	CSFFT512x512_Plan();
	engine_basic::engine_fail_reason create(UINT slices_in);
	UINT get_slices() { return slices; };

	void release();

private:
	engine_basic::engine_fail_reason create_cbuffers_512x512(UINT slices);
	template<class T>
	void SAFE_RELEASE(T t)
	{
		if (t != NULL)
		{
			t->Release();
			t = 0;
		}
	}
};
struct OceanParameter
{
	// Must be power of 2.
	int dmap_dim;
	// Typical value is 1000 ~ 2000
	float patch_length;
	// Adjust the time interval for simulation.
	float time_scale;
	// Amplitude for transverse wave. Around 1.0
	float wave_amplitude;
	// Wind direction. Normalization not required.
	XMFLOAT2 wind_dir;
	// Around 100 ~ 1000
	float wind_speed;
	// This value damps out the waves against the wind direction.
	// Smaller value means higher wind dependency.
	float wind_dependency;
	// The amplitude for longitudinal wave. Must be positive.
	float choppy_scale;
};
class OceanSimulator
{
public:
	OceanSimulator();
	engine_basic::engine_fail_reason create(OceanParameter& params);
	void release();
	// -------------------------- Initialization & simulation routines ------------------------

	// Update ocean wave when tick arrives.
	void updateDisplacementMap(float time);

	// Texture access
	ID3D11ShaderResourceView* getD3D11DisplacementMap();
	ID3D11ShaderResourceView* getD3D11GradientMap();

	const OceanParameter& getParameters();


protected:
	OceanParameter m_param;
	// ---------------------------------- GPU shading asset -----------------------------------
	// D3D objects
	ID3D11Device* m_pd3dDevice;
	ID3D11DeviceContext* m_pd3dImmediateContext;
	// Displacement map
	ID3D11Texture2D* m_pDisplacementMap;		// (RGBA32F)
	ID3D11ShaderResourceView* m_pDisplacementSRV;
	ID3D11RenderTargetView* m_pDisplacementRTV;
	// Gradient field
	ID3D11Texture2D* m_pGradientMap;			// (RGBA16F)
	ID3D11ShaderResourceView* m_pGradientSRV;
	ID3D11RenderTargetView* m_pGradientRTV;
	// Samplers
	ID3D11SamplerState* m_pPointSamplerState;
	// Initialize the vector field.
	void initHeightMap(OceanParameter& params, XMFLOAT2* out_h0, float* out_omega);
	// ----------------------------------- CS simulation data ---------------------------------

	// Initial height field H(0) generated by Phillips spectrum & Gauss distribution.
	ID3D11Buffer* m_pBuffer_Float2_H0;
	ID3D11UnorderedAccessView* m_pUAV_H0;
	ID3D11ShaderResourceView* m_pSRV_H0;
	// Angular frequency
	ID3D11Buffer* m_pBuffer_Float_Omega;
	ID3D11UnorderedAccessView* m_pUAV_Omega;
	ID3D11ShaderResourceView* m_pSRV_Omega;
	// Height field H(t), choppy field Dx(t) and Dy(t) in frequency domain, updated each frame.
	ID3D11Buffer* m_pBuffer_Float2_Ht;
	ID3D11UnorderedAccessView* m_pUAV_Ht;
	ID3D11ShaderResourceView* m_pSRV_Ht;
	// Height & choppy buffer in the space domain, corresponding to H(t), Dx(t) and Dy(t)
	ID3D11Buffer* m_pBuffer_Float_Dxyz;
	ID3D11UnorderedAccessView* m_pUAV_Dxyz;
	ID3D11ShaderResourceView* m_pSRV_Dxyz;
	ID3D11Buffer* m_pQuadVB;

	ID3D11Buffer* m_pImmutableCB;
	ID3D11Buffer* m_pPerFrameCB;

	// FFT wrap-up
	CSFFT512x512_Plan *m_fft_plan;
	engine_basic::engine_fail_reason createBufferAndUAV(ID3D11Device* pd3dDevice, void* data, UINT byte_width, UINT byte_stride, ID3D11Buffer** ppBuffer, ID3D11UnorderedAccessView** ppUAV, ID3D11ShaderResourceView** ppSRV);
	engine_basic::engine_fail_reason createTextureAndViews(ID3D11Device* pd3dDevice, UINT width, UINT height, DXGI_FORMAT format, ID3D11Texture2D** ppTex, ID3D11ShaderResourceView** ppSRV, ID3D11RenderTargetView** ppRTV);
	float Gauss();
	float Phillips(XMFLOAT2 K, XMFLOAT2 W, float v, float a, float dir_depend);
	void fft_512x512_c2c(CSFFT512x512_Plan* fft_plan, ID3D11UnorderedAccessView* pUAV_Dst, ID3D11ShaderResourceView* pSRV_Dst, ID3D11ShaderResourceView* pSRV_Src);
	void radix008A(CSFFT512x512_Plan* fft_plan, ID3D11UnorderedAccessView* pUAV_Dst, ID3D11ShaderResourceView* pSRV_Src, UINT thread_count, UINT istride);
#ifdef CS_DEBUG_BUFFER
	ID3D11Buffer* m_pDebugBuffer;
#endif
	template<class T>
	void SAFE_RELEASE(T t)
	{
		if (t != NULL)
		{
			t->Release();
			t = 0;
		}
	}
	template<class T>
	void SAFE_DELETE_ARRAY(T t)
	{
		if (t != NULL)
		{
			delete[] t;
			t = 0;
		}
	}
};
#define FRESNEL_TEX_SIZE			256
#define PERLIN_TEX_SIZE				64

struct ocean_vertex
{
	float index_x;
	float index_y;
};
// Quadtree structures & routines
struct QuadNode
{
	XMFLOAT2 bottom_left;
	float length;
	int lod;

	int sub_node[4];
};
struct QuadRenderParam
{
	UINT num_inner_verts;
	UINT num_inner_faces;
	UINT inner_start_index;

	UINT num_boundary_verts;
	UINT num_boundary_faces;
	UINT boundary_start_index;
};
// Constant buffer
struct Const_Per_Call
{
	XMFLOAT4X4	g_matLocal;
	XMFLOAT4X4	g_matWorldViewProj;
	XMFLOAT2 g_UVBase;
	XMFLOAT2 g_PerlinMovement;
	XMFLOAT3	g_LocalEye;
};

struct Const_Shading
{
	// Water-reflected sky color
	XMFLOAT3		g_SkyColor;
	float			unused0;
	// The color of bottomless water body
	XMFLOAT3		g_WaterbodyColor;

	// The strength, direction and color of sun streak
	float			g_Shineness;
	XMFLOAT3		g_SunDir;
	float			unused1;
	XMFLOAT3		g_SunColor;
	float			unused2;

	// The parameter is used for fixing an artifact
	XMFLOAT3		g_BendParam;

	// Perlin noise for distant wave crest
	float			g_PerlinSize;
	XMFLOAT3		g_PerlinAmplitude;
	float			unused3;
	XMFLOAT3		g_PerlinOctave;
	float			unused4;
	XMFLOAT3		g_PerlinGradient;

	// Constants for calculating texcoord from position
	float			g_TexelLength_x2;
	float			g_UVScale;
	float			g_UVOffset;
};

class FFT_ocean
{
	Geometry_basic           *fullscreen_buffer;
	// 网格数据:
	// Mesh grid dimension, must be 2^n. 4x4 ~ 256x256
	int g_MeshDim = 128;
	// Side length of square shaped mesh patch
	float g_PatchLength;
	// Dimension of displacement map
	int g_DisplaceMapDim;
	// Subdivision thredshold. Any quad covers more pixels than this value needs to be subdivided.
	float g_UpperGridCoverage = 64.0f;
	// Draw distance = g_PatchLength * 2^g_FurthestCover
	int g_FurthestCover = 8;
	XMFLOAT3 g_SkyColor = XMFLOAT3(0.38f, 0.45f, 0.56f);
	XMFLOAT3 g_WaterbodyColor = XMFLOAT3(0.07f, 0.15f, 0.2f);
	// Blending term for sky cubemap
	float g_SkyBlending = 16.0f;

	// Perlin wave parameters
	float g_PerlinSize = 1.0f;
	float g_PerlinSpeed = 0.06f;
	XMFLOAT3 g_PerlinAmplitude = XMFLOAT3(35, 42, 57);
	XMFLOAT3 g_PerlinGradient = XMFLOAT3(1.4f, 1.6f, 2.2f);
	XMFLOAT3 g_PerlinOctave = XMFLOAT3(1.12f, 0.59f, 0.23f);
	XMFLOAT2 g_WindDir;

	XMFLOAT3 g_BendParam = XMFLOAT3(0.1f, -0.4f, 0.2f);

	// Sunspot parameters
	XMFLOAT3 g_SunDir = XMFLOAT3(0.936016f, -0.343206f, 0.0780013f);
	XMFLOAT3 g_SunColor = XMFLOAT3(1.0f, 1.0f, 0.6f);
	float g_Shineness = 400.0f;
	//四叉树数据
	// Quad-tree LOD, 0 to 9 (1x1 ~ 512x512) 
	int g_Lods = 0;
	// Pattern lookup array. Filled at init time.
	QuadRenderParam g_mesh_patterns[9][3][3][3][3];
	// Pick a proper mesh pattern according to the adjacent patches.


	// Rendering list
	vector<QuadNode> g_render_list;


	// D3D11 buffers and layout
	ID3D11Buffer* g_pMeshVB = NULL;
	ID3D11Buffer* g_pMeshIB = NULL;
	ID3D11InputLayout* g_pMeshLayout = NULL;

	// Color look up 1D texture
	ID3D11Texture1D* g_pFresnelMap = NULL;
	ID3D11ShaderResourceView* g_pSRV_Fresnel = NULL;

	// Distant perlin wave
	ID3D11ShaderResourceView* g_pSRV_Perlin = NULL;

	// Environment maps
	ID3D11ShaderResourceView* g_pSRV_ReflectCube = NULL;

	// HLSL shaders
	ID3D11VertexShader* g_pOceanSurfVS = NULL;
	ID3D11PixelShader* g_pOceanSurfPS = NULL;
	ID3D11PixelShader* g_pWireframePS = NULL;

	// Samplers
	ID3D11SamplerState* g_pHeightSampler = NULL;
	ID3D11SamplerState* g_pGradientSampler = NULL;
	ID3D11SamplerState* g_pFresnelSampler = NULL;
	ID3D11SamplerState* g_pPerlinSampler = NULL;
	ID3D11SamplerState* g_pCubeSampler = NULL;
	ID3D11Buffer* g_pPerCallCB = NULL;
	ID3D11Buffer* g_pPerFrameCB = NULL;
	ID3D11Buffer* g_pShadingCB = NULL;

	// State blocks
	ID3D11RasterizerState* g_pRSState_Solid = NULL;
	ID3D11RasterizerState* g_pRSState_Wireframe = NULL;
	ID3D11DepthStencilState* g_pDSState_Disable = NULL;
	ID3D11BlendState* g_pBState_Transparent = NULL;

public:
	FFT_ocean();
	QuadRenderParam& selectMeshPattern(const QuadNode& quad_node);
	int buildNodeList(QuadNode& quad_node);
	// init & cleanup
	void initRenderResource(const OceanParameter& ocean_param, ID3D11Device* pd3dDevice, const DXGI_SURFACE_DESC* pBackBufferSurfaceDesc);
	void cleanupRenderResource();
	// create a triangle strip mesh for ocean surface.
	void createSurfaceMesh(ID3D11Device* pd3dDevice);
	// create color/fresnel lookup table.
	void createFresnelMap(ID3D11Device* pd3dDevice);
	// create perlin noise texture for far-sight rendering
	void loadTextures(ID3D11Device* pd3dDevice);
	// Rendering routines
	void renderShaded(ID3D11ShaderResourceView* displacemnet_map, ID3D11ShaderResourceView* gradient_map, float time, ID3D11DeviceContext* pd3dContext);
	void renderdraw(ID3D11ShaderResourceView* displacemnet_map, ID3D11ShaderResourceView* gradient_map, float time, ID3D11DeviceContext* pd3dContext);
	int generateBoundaryMesh(int left_degree, int right_degree, int bottom_degree, int top_degree, RECT vert_rect, DWORD* output);
	int generateInnerMesh(RECT vert_rect, DWORD* output);
	bool checkNodeVisibility(const QuadNode& quad_node);
	float estimateGridCoverage(const QuadNode& quad_node, float screen_area);
	bool isLeaf(const QuadNode& quad_node);
	int searchLeaf(const vector<QuadNode>& node_list, const XMFLOAT2& point);
	// Shader compilation
	//void release();

private:
	template<class T>
	void SAFE_RELEASE(T t)
	{
		if (t != NULL)
		{
			t->Release();
			t = 0;
		}
	}
	template<class T>
	void SAFE_DELETE_ARRAY(T t)
	{
		if (t != NULL)
		{
			delete[] t;
			t = 0;
		}
	}
};